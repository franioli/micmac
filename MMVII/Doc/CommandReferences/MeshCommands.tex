\chapter{Mesh related commands}


%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
%-----------------------------------------------------------------------

\section{Process of 3D meshes}

 {\tt MMVII} is not a point-cloud/mesh processing tool. However, during some devlopment, some
functionnalities appeared to be necessary and not easily accesible on open source.
As they may be usable in other context I describe them here.

%-----------------------------------------------------------------------
\subsection{MeshCheck}

\begin{verbatim}
 == Mandatory unnamed args : ==
  * string [FDP,Cloud] :: Name of input cloud/mesh
 == Optional named args : ==
  * [Name=Bin] bool :: Generate out in binary format ,[Default=false]
  * [Name=Out] string :: Name of output file if correction are done
  * [Name=Do2DC] bool :: check also as a 2D-triangulation (orientation) ,[Default=false]
  * [Name=Correct] bool :: Do correction, Defaut: Do It Out specified
\end{verbatim}

{\tt MicMac-V1} can generate mesh from a 3d point cloud with normal. For this it
uses the open source tool devlopped by M Kazhdan. Also this tool is robust,
it has sometime topologicall problem that can block further processing.
The command {\tt MeshCheck} has been developped to  detect and potentially
correct these problems.

The first problem detected   is the fact that the same point that is duplicate in
a single triangle  like $ABC$  with $P_A=P_B$. This point are detected and
if the option {\tt Correct} is activated, a graph-quotient algorithm is applied 
on point that are detected as multiple.

The second check is $3d$ surface orientatbility . A message indicating the detected
pair of adjacent triangle badly oriented is printed.  No correction is
done, because untill now no such problem was encounterred.

If the option {\tt Do2DC} is activated, the triangulation is considered
as a $2$ triangle (setting $z$ to $0$) and  the $2d$ orientation correctness is
tested (have all the triangle the same orientation).


%-----------------------------------------------------------------------
\subsection{MeshCloudClip}

\begin{verbatim}
 == Mandatory unnamed args : ==
  * string [FDP,Cloud] :: Name of input cloud/mesh
  * string [3DReg] :: Name of 3D masq

 == Optional named args : ==
  * [Name=Out] string :: Name of output file
  * [Name=Bin] bool :: Generate out in binary format ,[Default=false]
\end{verbatim}


The mesh generated by Poisson method generate a smooth extension of the surface
that can be problematic, for example in the surface devlopment process. This
commande allow to clip the mesh using a $3d$ region.  For now the region
must come in the {\tt MicMac-V1} format as seized by {\tt mm3d SaisieMasqQT}
as for now there is no well established format for $3d$ volumes.
Figure~\ref{fig:MeshClip} illustrate the result of {\tt MeshCloudClip}

\begin{figure}
\centering
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/MeshWithSkirt.jpg}
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/MeshCliped.jpg}
\caption{Letft mesh with undesirable extension, right mesh after clipping}
\label{fig:MeshClip}
\end{figure}



%-----------------------------------------------------------------------
%-----------------------------------------------------------------------
%-----------------------------------------------------------------------

\section{Mesh development}

This section describe the tools that were devloped for surface devlopment.

%-----------------------------------------------------------------------
\subsection{MeshDevGen}
This "tiny" tool was made to check the correctness of the surface devlopment algorithm. 
It generate a synthetic mesh, that is completely devlopable and for with we
know the 2 devlopment. This surface is a $3$ extrusion of a logarithmic spiral.

Figure~\ref{fig:SpirAndDev} represent the 3D surface and its developped 2d surface.

\begin{figure}
\centering
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/Cyl3D01.jpg}
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/CylDev00.jpg}
\caption{A synthetic 3D mesh, and its generated devloped surface}
\label{fig:SpirAndDev}
\end{figure}

%-----------------------------------------------------------------------
\subsection{MeshDev}

\begin{verbatim}
== Mandatory unnamed args : ==
  * string [FDP,Cloud] :: Name of input cloud/mesh
== Optional named args : ==
  * [Name=Out] string :: Name of output file
  * [Name=Bin] bool :: Generate out in binary format ,[Default=false]
  * [Name=NbCByS] int :: Number of compensation by step ,[Default=3]
  * [Name=ShowAv] bool :: Show advancement of computation ,[Default=true]
  * [Name=CheckReach] bool :: Check reached face&som at end ,[Default=true]
  * [Name=WDistE] double :: Weight on edge dist ,[Default=0]
  * [Name=WRot] double :: Weight on rot on 2d triangles ,[Default=1]
  * [Name=NbIE] int :: Number of iteration at end
\end{verbatim}

\begin{figure}
\centering
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/Mesh3D.jpg}
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/Mesh2D.jpg}
\caption{A "real" mesh and its devlopment after MeshDev}
\label{fig:RealDev}
\end{figure}


This tool is used to make the $2d$ development of a $3d$ surface. As the real surface
is generally not strictly devlopable, this is done by minimzing the energy of deformation.
Figure~\ref{fig:RealDev} presents a $3d$ mesh and its $2d$ devlopment.
The constraint is that the devlopment must be, as much as possible isometric (distance on
the plane is the same that geodetic distance on $3d$ surface).  More precisely :

\begin{itemize}
      \item let  $P_i$ be the $3d$ points of the triangulation, $P_i \in \RR^3$;
      \item let  $\phi(P_i)$ be unknown $2d$  position of the devlopment $\phi(P_i) \in \RR^2$;
      \item let  $\mathcal{T}_t = \{P_{t_1},P_{t_2},P_{t_3}\}, t \in [1,T] $ be the $T$ triangles;
\end{itemize}


The command offers different option corresponding to different formalization of the isometry.
The simpler is given by :

\begin{equation}
   E_d(\phi) =   \sum_{t=1}^T \sum_{m,n=1}^3  \{ d(P_{t_m},P_{t_m})-  d(\phi(P_{t_m}),\phi(P_{t_m})) \}  ^2
   \label{DevEqDist}
\end{equation}

For technicall reason (see paper to come) the equation~\ref{DevEqDist} is not stable and
the equation~\ref{Eq:MeshDev1T} is generally preferable.
For each triangle  $\mathcal{T}_t$ \emph{independantly} we can easily compute a \emph{perfect} development
in a $2d$ triangle $\mathcal{T}^2_k$= $q_{t_1},q_{t_2},q_{t_3}$, such that 
$d(q_{t_n},q_{t_m})=d(P_{t_m},P_{t_n}) \; m,n \in (1,2,3)$, so if the development
were perfect, there would exist for each triangle a rotation $R^t$ such that :

\begin{equation}
	\phi(P_{t_m}) =  R^t q^t_m  \;\; m \in (1,2,3) \label{Eq:MeshDev1T}
\end{equation}


Let note $\psi$ the application associate a rotation to each triangle $R^t = \psi(\mathcal{T}_t)=$.
We then try to compute simultaneously the $\phi$ and $\psi$ that minizes globaly the 
formula of equation~\ref{Eq:MeshDev1T} :

\begin{equation}
    E_R(\phi,\psi)= \sum_{t=1}^T \sum_{m=1}^3  d\{\phi(P_{t_m}) - \psi(\mathcal{T}_t)(q_{t_m})\} ^2
\end{equation}

%-----------------------------------------------------------------------

\subsection{MeshProjImage}

\subsubsection{General use}

\begin{verbatim}
 == Mandatory unnamed args : ==
  * string [MPF0,FDP] :: Name of image
  * string [Cloud,In] :: Name of input cloud/mesh
  * string [Ori,In] :: Input Ori
  * string [MeshDev,Out] :: Output MeshDev
 == Optional named args : ==
  * [Name=M2] string [Cloud,In] :: Mesh 2D, dev of cloud 3D,to generate a visu of hiden part
  * [Name=ResZBuf] double :: Resolution of ZBuffer ,[Default=3]
  * [Name=DoIm] bool :: Do images ,[Default=false]
  * [Name=NbPixIR] int :: Resolution of ZBuffer ,[Default=2000]
  * [Name=MII] double :: Margin Inside Image (for triangle validation) ,[Default=4]
  * [Name=SkWE] bool :: Skip command when result exist
  * [Name=OutRad] string [Rad,Out] :: Output Rad
  * [Name=FFI0] string [FFI0] :: File Filter Interval, Main Set
\end{verbatim}

This command is used to prepare the image devlopment taking into account the orientation of the
camera and a $3$ surface.  It must decides for each triangle, which is the best image to
use for creating textures . For each image and each triangle, the method :

\begin{itemize}
    \item decide if the triangle is visible, this is done copmputing a ZBuffer;
    \item for a visible triangle, computes the resolution (precisely the lowest resolution 
          on all the possible direction);
\end{itemize}

Finally the  command select for each triangle the image having the best resolution among the images where
the triangle is visible.

\begin{figure}
\centering
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/Image_P1056148.jpg}
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/ZBuf.jpg}
\caption{An image , the ZBuffer computed,the view on devloped mesh of visibility and resolution}
\label{fig:RealDevZB}
\end{figure}

The figure~\ref{fig:RealDevZB} presents some intermediar result computed during
this commande.  The left image is just the image used to illustrate the computation,
the right image is the zbuf computed, by default this z-buffer is not saved as it is
just an intermediar of computation, if wanted for illusration the {\tt DoIm=true} activates that.

\begin{figure}
\centering
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/Dev-P1056148.jpg}
\includegraphics[width=6cm]{CommandReferences/ImagesComRef/LabTri.jpg}
\caption{Left visibility an resolution for $1$ image, right visualisation of selected triangle}
\label{fig:RealDevTri}
\end{figure}

The figure~\ref{fig:RealDevTri} presents the result of computation, these two images are in the
geometry of devlopped $2d$ surface :

\begin{itemize}
    \item left  image present the visiblity of triangle , gray triangle are visible and the gray value is
          proportionnal to the computed resolution; cyan correspond to background (no triangle or triangle
          dont project in image),  red present triangle that are correctly oriented but occluded by others,
          green present the triangle that cannot be visible due to their orientation;

    \item right image present the result of best triangle selection using a random palette (same color
          visualize triangles affected to the same image;

\end{itemize}

     %  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -

\subsubsection{Radiometry computation}

An important option of the command is {\tt OurRad},  if used it will generate in
the specifying folder data that can be used for radiometric equalization (see
chapter \ref{Chap:Radiom} for structures of such data). Some details :

\begin{itemize}
    \item each $3d$ triangle is sampled on a grid , each of this point 

\end{itemize}



\subsubsection{Result}

The results are stored in a folder computed from the $4^{th}$ parameter.



%-----------------------------------------------------------------------
\subsection{MeshImageDevlp}

\begin{verbatim}
== Mandatory unnamed args : ==
  * string [FDP] :: Name of 2d devloped mesh
  * string [MeshDev,In] :: Input MeshDev
 == Optional named args : ==
  * [Name=WGL] bool :: With Gray Label 2-byte image generation ,[Default=false]
  * [Name=WRGBL] bool :: With RGB Label  1 chanel-label/2 label contrast ,[Default=false]
  * [Name=InRad] string [Rad,In] :: Input Rad
\end{verbatim}

This command is used for computing effectively the $2d$ devlopment of the image . Its takes two mandatory
parameters :

\begin{itemize}
   \item the $2d$ mesh as resulting from the command {\tt MeshDev};
   \item the folder containing the result of {\tt MeshProjImage};
\end{itemize}

If the images are to be equalized before devlopment, The optionnal parameter {\tt InRad} 
indicate where the radiometric equalization data can be found.  

The parameter {\tt WGL} and {\tt WRGBL} can be used to generate visualization as the one
of figure~\ref{fig:RealDevTri}, except for didactic or debugging, they will be generally not usefull.
 With {\tt WGL} a gray level- $16$ bits- image is generated,
each level indicating the id of the triangle. With {\tt WRGBL}, a rgb-$8$ bits- image is generated, the 
blue channel indicate the num of the triangle, while red and green channel are selected to maximize
the contrast.



